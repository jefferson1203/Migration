package main

/*
import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"math/rand"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

var (
	simulationState SimulationState
	isRunning       bool
	timeStep        int = 1
	db              *sql.DB

	// Channels for synchronisation
	stateChan             chan simulationRequest
	configChan            chan configRequest
	timeStepChan          chan timeStepRequest
	simulationControlChan chan simulationControlRequest
)

type simulationRequest struct {
	responseChan chan SimulationState
}

type configRequest struct {
	responseChan chan SimulationConfig
}

type timeStepRequest struct {
	newTimeStep  int
	responseChan chan int
}

type simulationControlRequest struct {
	action       string
	responseChan chan bool
}

func init() {
	// Load configuration
	LoadConfig()

	// Initialize SQLite database
	var err error
	db, err = sql.Open("sqlite3", config.DBPath)
	if err != nil {
		log.Fatal(err)
	}

	err = initDatabase()
	if err != nil {
		log.Fatal(err)
	}

	// Init simulation
	InitSimulation()
	//init channels
	stateChan = make(chan simulationRequest)
	configChan = make(chan configRequest)
	timeStepChan = make(chan timeStepRequest)
	simulationControlChan = make(chan simulationControlRequest)

	go StartSimulationLoop()

}

func initDatabase() error {
	_, err := db.Exec(`
        CREATE TABLE IF NOT EXISTS saved_states (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            state TEXT,
			config TEXT,
			time_step INTEGER,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `)
	if err != nil {
		return fmt.Errorf("error creating saved_states table: %w", err)
	}
	return nil
}

func InitSimulation() {

	simulationState.Birds = make([]Bird, config.InitialBirds)
	rand.Seed(time.Now().UnixNano())

	//Generate obstacles
	simulationState.Obstacles = make([]Obstacle, config.ObstacleCount)
	for i := range simulationState.Obstacles {
		simulationState.Obstacles[i] = Obstacle{
			ID:       i,
			Position: [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)},
			Radius:   rand.Float64()*15 + 5,
		}
	}

	//Generate resources
	simulationState.Resources = make([]Resource, config.ResourceCount)
	for i := range simulationState.Resources {
		resourceType := "food"
		if i%2 == 0 {
			resourceType = "rest"
		}
		simulationState.Resources[i] = Resource{
			ID:       i,
			Position: [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)},
			Type:     resourceType,
			Capacity: 10,
			Current:  0,
		}
	}

	for i := range simulationState.Birds {
		simulationState.Birds[i] = Bird{
			ID:       i,
			Position: [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)},
			Velocity: [2]float64{rand.Float64() - 0.5, rand.Float64() - 0.5},
			State:    "migrating",
			Target:   [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)},
		}
	}
	simulationState.Time = 0
	simulationState.IsRunning = isRunning
	simulationState.WorldSize = config.WorldSize
}

func StartSimulation() {
	responseChan := make(chan bool)
	simulationControlChan <- simulationControlRequest{
		action:       "start",
		responseChan: responseChan,
	}
	<-responseChan
}

func StopSimulation() {
	responseChan := make(chan bool)
	simulationControlChan <- simulationControlRequest{
		action:       "stop",
		responseChan: responseChan,
	}
	<-responseChan
}

func updateSimulation() {
	if !isRunning {
		return
	}

	for i := range simulationState.Birds {
		bird := &simulationState.Birds[i]
		switch bird.State {
		case "migrating":
			updateMigratingBird(bird)
		case "resting":
			updateRestingBird(bird)
		case "searchingFood":
			updateSearchingFoodBird(bird)
		}
	}
	simulationState.Time++
}

func updateMigratingBird(bird *Bird) {
	//find next target
	if distance(bird.Position, bird.Target) < 10 {
		bird.Target = [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)}
	}

	//move to target
	direction := [2]float64{bird.Target[0] - bird.Position[0], bird.Target[1] - bird.Position[1]}
	normalizedDirection := normalize(direction)
	bird.Velocity = [2]float64{normalizedDirection[0], normalizedDirection[1]}
	bird.Position[0] += bird.Velocity[0] * float64(timeStep)
	bird.Position[1] += bird.Velocity[1] * float64(timeStep)

	// Evade obstacles
	evadeObstacles(bird)

	// Simple rule: birds rest after migrating for a while, or when they are near a rest resource
	if simulationState.Time%(1000) == 0 {
		closestResource, _ := findClosestResource(bird.Position, "rest")
		if closestResource != nil && distance(bird.Position, closestResource.Position) < 50 {
			bird.State = "resting"
			closestResource.Current++
		}
	} else if simulationState.Time%(700) == 0 {
		closestResource, _ := findClosestResource(bird.Position, "food")
		if closestResource != nil && closestResource.Current < closestResource.Capacity && distance(bird.Position, closestResource.Position) < 50 {
			bird.State = "searchingFood"
			closestResource.Current++
		}
	}
}

func updateRestingBird(bird *Bird) {
	// after resting, resume migration
	if simulationState.Time%(1000) == 100 {
		bird.State = "migrating"
		closestResource, index := findClosestResource(bird.Position, "rest")
		if closestResource != nil {
			simulationState.Resources[index].Current--
		}
		bird.Target = [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)}
	}
}

func updateSearchingFoodBird(bird *Bird) {
	closestResource, index := findClosestResource(bird.Position, "food")
	if closestResource == nil || closestResource.Current >= closestResource.Capacity {
		bird.State = "migrating"
		bird.Target = [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)}
		return
	}
	//move to target
	direction := [2]float64{closestResource.Position[0] - bird.Position[0], closestResource.Position[1] - bird.Position[1]}
	normalizedDirection := normalize(direction)
	bird.Velocity = [2]float64{normalizedDirection[0], normalizedDirection[1]}
	bird.Position[0] += bird.Velocity[0] * float64(timeStep)
	bird.Position[1] += bird.Velocity[1] * float64(timeStep)
	if distance(bird.Position, closestResource.Position) < 10 {
		bird.State = "migrating"
		simulationState.Resources[index].Current--
		bird.Target = [2]float64{rand.Float64() * float64(config.WorldSize), rand.Float64() * float64(config.WorldSize)}
	}
}

func evadeObstacles(bird *Bird) {
	for _, obstacle := range simulationState.Obstacles {
		dist := distance(bird.Position, obstacle.Position)
		if dist < obstacle.Radius+10 {
			evadeDirection := [2]float64{bird.Position[0] - obstacle.Position[0], bird.Position[1] - obstacle.Position[1]}
			normalizedEvade := normalize(evadeDirection)
			bird.Velocity = [2]float64{bird.Velocity[0] + normalizedEvade[0]*0.5, bird.Velocity[1] + normalizedEvade[1]*0.5} // Change Velocity to avoid the obstacle
		}
	}
}

func distance(pos1 [2]float64, pos2 [2]float64) float64 {
	dx := pos1[0] - pos2[0]
	dy := pos1[1] - pos2[1]
	return math.Sqrt(dx*dx + dy*dy)
}

func normalize(vec [2]float64) [2]float64 {
	mag := math.Sqrt(vec[0]*vec[0] + vec[1]*vec[1])
	if mag > 0 {
		return [2]float64{vec[0] / mag, vec[1] / mag}
	}
	return vec
}

func findClosestResource(pos [2]float64, resourceType string) (*Resource, int) {
	var closest *Resource
	var closestIndex int
	minDist := math.MaxFloat64
	found := false

	for index, res := range simulationState.Resources {
		if res.Type == resourceType {
			dist := distance(pos, res.Position)
			if dist < minDist {
				minDist = dist
				closest = &res
				closestIndex = index
				found = true
			}
		}
	}
	if found {
		return closest, closestIndex
	}

	return nil, -1
}

func StartSimulationLoop() {
	ticker := time.NewTicker(time.Duration(config.SimulationSpeed) * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			updateSimulation()
		case req := <-simulationControlChan:
			switch req.action {
			case "start":
				isRunning = true
				simulationState.IsRunning = isRunning
				req.responseChan <- true
			case "stop":
				isRunning = false
				simulationState.IsRunning = isRunning
				req.responseChan <- true
			}
		}
	}
}

func GetSimulationState() SimulationState {
	responseChan := make(chan SimulationState)
	stateChan <- simulationRequest{
		responseChan: responseChan,
	}
	return <-responseChan
}

func GetSimulationConfig() SimulationConfig {
	responseChan := make(chan SimulationConfig)
	configChan <- configRequest{
		responseChan: responseChan,
	}
	return <-responseChan
}

func SetSimulationConfig(newConfig SimulationConfig) {
	responseChan := make(chan SimulationConfig)
	configChan <- configRequest{
		responseChan: responseChan,
	}
	setSimulationConfigHelper(newConfig)
	<-responseChan
}

func setSimulationConfigHelper(newConfig SimulationConfig) {

	config.SimulationSpeed = newConfig.SimulationSpeed
	config.WorldSize = newConfig.WorldSize
	config.ObstacleCount = newConfig.ObstacleCount
	config.ResourceCount = newConfig.ResourceCount

	simulationState.WorldSize = config.WorldSize

}

func SetTimeStep(newTimeStep int) {
	responseChan := make(chan int)
	timeStepChan <- timeStepRequest{
		newTimeStep:  newTimeStep,
		responseChan: responseChan,
	}
	timeStep = <-responseChan
	log.Printf("Time step set to %d \n", timeStep)
}

func GetTimeStep() int {
	responseChan := make(chan int)
	timeStepChan <- timeStepRequest{
		responseChan: responseChan,
	}
	return <-responseChan
}

func SaveSimulationState() error {

	stateJSON, err := json.Marshal(simulationState)
	if err != nil {
		return fmt.Errorf("error marshaling simulation state: %w", err)
	}

	configJSON, err := json.Marshal(SimulationConfig{
		SimulationSpeed: config.SimulationSpeed,
		WorldSize:       config.WorldSize,
		ObstacleCount:   config.ObstacleCount,
		ResourceCount:   config.ResourceCount,
	})
	if err != nil {
		return fmt.Errorf("error marshaling simulation config: %w", err)
	}

	_, err = db.Exec("INSERT INTO saved_states (state, config, time_step) VALUES (?, ?, ?)", stateJSON, configJSON, timeStep)
	if err != nil {
		return fmt.Errorf("error saving simulation state to DB: %w", err)
	}

	return nil
}

func LoadSimulationState() (*SaveState, error) {
	var stateJSON string
	var configJSON string
	var timeStep int

	row := db.QueryRow("SELECT state, config, time_step FROM saved_states ORDER BY id DESC LIMIT 1")
	err := row.Scan(&stateJSON, &configJSON, &timeStep)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("no saved state found")
	}
	if err != nil {
		return nil, fmt.Errorf("error loading simulation state from DB: %w", err)
	}

	var loadedState SimulationState
	if err := json.Unmarshal([]byte(stateJSON), &loadedState); err != nil {
		return nil, fmt.Errorf("error unmarshaling simulation state: %w", err)
	}

	var loadedConfig SimulationConfig
	if err := json.Unmarshal([]byte(configJSON), &loadedConfig); err != nil {
		return nil, fmt.Errorf("error unmarshaling simulation config: %w", err)
	}

	simulationState = loadedState
	config.SimulationSpeed = loadedConfig.SimulationSpeed
	config.WorldSize = loadedConfig.WorldSize
	config.ObstacleCount = loadedConfig.ObstacleCount
	config.ResourceCount = loadedConfig.ResourceCount
	simulationState.IsRunning = false
	isRunning = false
	timeStep = timeStep

	return &SaveState{
		State:    loadedState,
		Config:   loadedConfig,
		TimeStep: timeStep,
	}, nil

}
*/
